import java.util.BitSet;
import Semantic.*;
COMPILER OpenHugs

Node root = new Node("root",-1,null);
Node currentNode = root;

ProgramScope program;
ClassScope currentClass;
MethodScope currentMethod;

void debug (String str){
  //System.err.println(str);
}


String ss(){
  return ss(0);
}

String ss( int n ){
  scanner.ResetPeek(); 
  Token next = la;
  for (int i = 0; i < n ; i ++) next = scanner.Peek(); 
  return next.val;
}

boolean isFunctionCall() {
 scanner.ResetPeek(); 
 Token next = scanner.Peek();
 return  next.kind == _lpar;
} 

boolean isAsignment() {
 scanner.ResetPeek(); 
 Token next = scanner.Peek();
 return  next.kind == _asign;
}

boolean isElseClause(){
  scanner.ResetPeek();
  Token next = scanner.Peek();
  return  next.kind == _sino || la.kind == _sino ;
}

void pushNode(){
  Node newNode = new Node(scanner.pt.val, scanner.pt.kind, currentNode);
  currentNode.children.add(newNode);
  currentNode = newNode;
}

void popNode(){
  currentNode = currentNode.parent;
}

void addChildren(){
  currentNode.children.add(new Node(scanner.pt.val, scanner.pt.kind, currentNode));
}

/*-------------------------------------------------------------------------*/

CHARACTERS
  tab           = '\u0009'. /*  9 = tabulator */
  lf            = '\u000a'. /* 10 = line feed */
  cr            = '\u000d'. /* 13 = carriage return */
  upper         = 'A' .. 'Z'.
  lower         = 'a' .. 'z'.

  digit         = "0123456789".
  letter        = upper + lower + '_' + '$'.

  stringChar    = ANY - "\"" - '\\' - cr - lf.

TOKENS
  
  lineEnd = lf {{tab}lf}.
  
  variableName = lower{lower}.
  
  className = upper{lower}.
  
  number = digit { digit } ['.' digit { digit } ].
  
  stringLit = 
  "\"" { stringChar
       | "\\" ( "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\" )
       } 
  "\"".
  
  /*----- operators and special characters needed in LL(1) resolvers --------------*/
  comma   = ",".
  dec     = "--".
  dot     = ".".
  inc     = "++".
  lbrace  = "{".
  lbrack  = "[".
  lpar    = "(".
  minus   = "-".
  not     = "!".
  plus    = "+".
  rbrace  = "}".
  rbrack  = "]".
  rpar    = ")".
  tilde   = "~".
  asign = ":=".
  mul = "*".
  div = "/".
  colon = ":".
  leq = "<=".
  geq = ">=".
  less = "<".
  great = ">".
  equal = "==".
  notEq = "!=".
  and = "Y".
  or = "O".

  /*----- Reserved words ----------------------------------------------------------*/
  
  si = "SI".
  ciclo = "CICLO".
  mientras = "MIENTRAS".
  sino = "SINO".
  clase = "CLASE".
  incorporar = "INCORPORAR".
  funcion = "FUNCION".
  numero = "NUMERO".
  palabra = "PALABRA".
  returns = "RETORNA".
  return = "RETORNAR".
  bool = "LOGICO".
  true = "VERDADERO".
  false = "FALSO".
  


COMMENTS FROM ";;" TO ";;"
COMMENTS FROM ";" TO lf


IGNORE cr + tab

/*---------------------------------------------------------------------------*/

PRODUCTIONS

OpenHugs = (. program = new ProgramScope(); .) [lineEnd] {include} classDeclaration {classDeclaration} .

completeClassName = className{ dot className} [ colon typeName {comma typeName } not ].

tipoRetorno = numero | bool | palabra | completeClassName .

include = incorporar className { dot className} lineEnd .

classDeclaration = 
(. currentClass = program.addClass(ss(1)); .) clase className [ colon typeName {comma typeName}] classBlock [lineEnd]
(. currentClass = null; .) .

functionDeclaration = (. currentMethod = currentClass.addMethod(ss(1)); .) funcion variableName lpar [parameterList] rpar [returns (.currentMethod.setReturnType(ss()); .) tipoRetorno] [lineEnd] StatementBlock
(. currentMethod = null; .).

parameterList = functionParameter {comma functionParameter} .

functionParameter = (. currentMethod.addVariable(ss(0)); .) typeName variableName .

variableDeclaration = (. if (currentMethod == null)  currentClass.addVariable(ss(1)); else currentMethod.addVariable(ss(1)); .)
typeName variableName [asign expresion] .

assignment = (. currentMethod.lookUpVariable(ss()); .) variableName asign expresion
(. debug("asignacion"); .)
.

whileLoop = ciclo (. debug("while"); .) mientras lpar logExpresion rpar StatementBlock.

ifStatement = si (. debug("if"); .) lpar logExpresion rpar StatementBlock [IF (isElseClause()) [lineEnd] sino (. debug("else"); .) StatementBlock ].

functionCall = (. currentClass.lookUpMethod(ss()); .) variableName lpar [expresion { comma expresion } ]  rpar (. addChildren(); .).

typeName = completeClassName | numero | palabra | bool.

expresion = 
  numExpresion | logExpresion | strExpression.
  
strExpression = 
  ( lpar strExpression rpar
  | stringLit
  | variableName )
    [ plus strExpression].

numExpresion =
  ((lpar numExpresion rpar
  | IF( isFunctionCall() ) functionCall
  | number
  | variableName  [ inc
                  | dec ]
                  ) [ minus numExpresion
                    | plus numExpresion
                    | mul numExpresion
                    | div numExpresion ] ).

logExpresion =
  ((not logExpresion
  | lpar logExpresion rpar
  | IF( isFunctionCall() ) functionCall
  | variableName 
  | boolValue )   [ and logExpresion
                  | or logExpresion ] )
  | numExpresion  ( leq numExpresion
                  | geq numExpresion
                  | less numExpresion
                  | great numExpresion
                  | equal numExpresion
                  | notEq numExpresion ) .


boolValue = true | false .

StatementBlock = lbrace (.pushNode(); .)
                        [lineEnd] { ( IF(isAsignment()) assignment  
                                      | whileLoop 
                                      | ifStatement 
                                      | IF( isFunctionCall() ) functionCall
                                      | variableDeclaration
                                      | increment
                                      | return expresion
                                    ) lineEnd } rbrace (. popNode(); .).
                                    
increment = (. currentMethod.lookUpVariable(ss()); .) variableName (inc | dec) .

classBlock =  lbrace (. pushNode(); .)
              lineEnd {(functionDeclaration | variableDeclaration) lineEnd} 
              rbrace(. popNode(); .). 

END OpenHugs.